<html>
    <head>
        <style>
            body {
                margin-left: 5%;
            }
        </style>
        
    </head>
    <body onload="startGame()">
        <h1>Mouse Chaser</h1>
        <p>Move the mouse around the canvas.</p>
        <ul>
            <li>Square that moves with mouse.</li>
            <li>Square that chases the player.</li>
            <li>3 lives.</li>
            <li>EXTRA: Smooth movement (time for trig)</li>
        </ul>

        
        <canvas id="playArea" width=500 height=250 style="border:1px solid #000"></canvas>
        <div id="lifeCounter" style="margin-top: 15px; font-size: 25px">3 lives left</div>
        <button id="resetButton" onclick="fullGameReset();">Reset</button>

        <div id="CoordDisplay">X: <br/>Y: </div>
        <script>
            //Thank (the) [INSERT DEITY NAME HERE] for w3schools.com
            //EDIT: Also stackoverflow.com

            //VARIABLE DEFINITIONS
            var playerPiece;
            var enemyPiece;
            var playerLives = 4;
            var enemySpeed = 2;
            var currentFrame = 0;
            var delta = 0;
            var lastFrame = 0;
            
            var coordsTrackerPos = 0;
            var coordsTracker = new Array(4);
            /* Array constructor notes:
                The constructor behaves differently under different circumstances.
                If 1 parameter has been given, it will create an array of that length. 
                Ex: new Array(4) => [,,,]
                If 2 or more parameters have been given, it will create an array with those elements.
                Ex: new Array(1,5,9) => [1,5,9]
            */

            //DOM GRABBERS
            var lifeCounter = document.getElementById("lifeCounter");
            var resetButton = document.getElementById("resetButton");
            var coordDisplay = document.getElementById("CoordDisplay");

            //OBJECT DEFINITIONS
            var gameSpace = {
                canvas : document.createElement("canvas"),
                start : function() {
                    var oldCanvas = document.getElementById("playArea");
                    this.canvas.width = oldCanvas.width;
                    this.canvas.height = oldCanvas.height;
                    this.canvas.style = "border:1px solid #000";
                    this.canvas.id = "playArea";
                    //canvasRef = this.canvas;
                    this.context = this.canvas.getContext("2d");

                    //Pick the pre-existing playArea and replace it with a less annoying one.
                    //var oldCanvas = document.getElementById("playArea");
                    oldCanvas.parentNode.replaceChild(this.canvas, oldCanvas);

                    
                    
                    //NOTE: The change from setInterval to animation frame made this noticeably smoother.
                    //this.interval = setInterval(updateGameArea, 20);
                    window.requestAnimationFrame(updateGame);
                    this.canvas.addEventListener('mousemove', function(event) {
                        gameSpace.plrX = event.offsetX;
                        gameSpace.plrY = event.offsetY;
                    });
                    this.canvas.addEventListener("click", function(){
                        var canvasRef = document.getElementById("playArea");
                        var mouseX = event.offsetX;
                        var mouseY = event.offsetY;
                        var cWidth = canvasRef.width;
                        var cHeight = canvasRef.height;
                        /*coordsTracker[coordsTrackerPos] = [mouseX,mouseY];
                        if (coordsTrackerPos < 3){
                            coordsTrackerPos++;
                        } else {
                            coordsTrackerPos = 0;
                        }*/
                        /*Guess which corner has been clicked 
                            NOTE: Each corner IS DEFINED by its quadrant!
                            NEXT: Figure out custom corners.
                        */
                        if (mouseX > (cWidth/2)) {
                            coordsTrackerPos = 2; //Right side of canvas
                        } else {
                            coordsTrackerPos = 0; //Left side of canvas
                        }
                        if (mouseY > (cHeight/2)) {
                            coordsTrackerPos += 1;
                        } else {
                            coordsTrackerPos += 0;
                        }
                        coordsTracker[coordsTrackerPos] = [mouseX,mouseY];
                        coordDisplay.innerHTML = "X: " + mouseX + " <br/>Y: " + mouseY + "<br/> Pos: " + coordsTrackerPos + "<br/>" + coordsTracker;
                    });
                },
                clear : function(){this.context.clearRect(0, 0, this.canvas.width, this.canvas.height)}
            }
            
            function gamePiece(width, height, color, x, y) {
                this.width = width;
                this.height = height;
                this.x = this.initialX = x;
                this.y = this.initialY = y;
                this.update = function() {
                    ctx = gameSpace.context;
                    ctx.fillStyle = color;
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                    this.relX = this.width/2+this.x; // Middle X coord of this shape (relative X)
                    this.relY = this.height/2+this.y; // Middle Y coord of this shape (relative Y)
                }
                this.crashWith = function(otherobj) {

                    var myleft = this.x;
                    var myright = this.x + (this.width);
                    var mytop = this.y;
                    var mybottom = this.y + (this.height);
                    var otherleft = otherobj.x;
                    var otherright = otherobj.x + (otherobj.width);
                    var othertop = otherobj.y;
                    var otherbottom = otherobj.y + (otherobj.height);
                    var crash = true;
                    if ((mybottom < othertop) ||
                        (mytop > otherbottom) ||
                        (myright < otherleft) ||
                        (myleft > otherright)) {
                            crash = false;
                    }
                    return crash;
                }

                this.resetPiece = function() {
                    this.x = this.initialX;
                    this.y = this.initialY;
                }
            }

            //FUNCTION DEFINITIONS
            function startGame() {
                gameSpace.start();
                playerPiece = new gamePiece(25, 25, "#0B0", 10, 215);
                enemyPiece = new gamePiece(25, 25, "#F00", 465, 10);
            }

            function resetGame() {
                gameSpace.clear();
                playerPiece.resetPiece();
                enemyPiece.resetPiece();
                playerPiece.update();
                enemyPiece.update();
                console.log("Game Reset!");
                setTimeout(updateGame,1500);
            }

            function updateGame() {
                if (enemyPiece.crashWith(playerPiece)) {
                    console.log("Crashed!");
                    window.cancelAnimationFrame(currentFrame);
                    playerLives -= 1;
                    if (playerLives <= 0) {
                        lifeCounter.innerHTML = "Game Over";
                    } else {
                        lifeCounter.innerHTML = playerLives + " lives left";
                        resetGame();
                    }
                } else {
                    //console.log("Survived!");
                    gameSpace.clear();
                    //Check the existence of mousemove event coords.
                    //Then move the playerPiece's middle to the mouse.
                    //Player piece movement
                    if (gameSpace.plrX && gameSpace.plrY) {
                        playerPiece.x = gameSpace.plrX-(playerPiece.width/2);
                        playerPiece.y = gameSpace.plrY-(playerPiece.height/2);    
                    }

                    //Enemy piece movement
                    
                    newEnemyCoords = calcNewCoords(enemyPiece,playerPiece,currentFrame);
                    //displayTheta.innerHTML = "Angle: " + newEnemyCoords.theta;

                    enemyPiece.x += newEnemyCoords.x;
                    enemyPiece.y += newEnemyCoords.y;
                    
                    playerPiece.update();
                    enemyPiece.update();
                    currentFrame = window.requestAnimationFrame(updateGame);
                }
                
            }
            
            /*ISSUE: The reset button calls this function EVERY TIME that it's pressed.
                This results in the enemyPiece reaching higher than expected speeds.

                Potential solution 1: introduce a "am I resetting right now?" flag
                Result: No change (seemingly)

                PS2: Manipulate the button such that you can't press it consecutivelly
                Result: Annoying button (loses functionality for some time)
                NOTE: This doesn't fix the issue. I plan to spend time designing this properly.

                PS3: Wrap the main section of this code within a game init function?
                Then, just call that? Hmm...
                Result: The problem has gotten worse in a hillarious manner!

                PS4: Refresh the page. I can't think of a better way to reinit the game...
                Without reinitialing it every single time the button has been clicked...

                Current Situation: The button's initial behaviour doesn't affect 
                the functionality of this game too much; thus, I shall implement its initial 
                behaviour (in order to help implement extension 01, as well). 
            */
            function fullGameReset() {
                playerLives = 3;
                lifeCounter.innerHTML = playerLives + " lives left";
                resetGame();
            }
            
            //Take the x and y coords of 2 objects and calculate the new x and y coords 
            //for getting from the starting object to the destination object.
            //Ended up using this: https://www.reddit.com/r/javascript/comments/2pty1w/how_do_i_make_an_object_chase_an_other_object/
            function calcNewCoords(startObj,destinationObj,currentFrame) {
                var dx = destinationObj.relX - startObj.relX; //Delta X
                var dy = destinationObj.relY - startObj.relY; //Delta Y
                
                // normalize (= direction vector)
                // (a direction vector has a length of 1)
                var length = Math.sqrt(dx * dx + dy * dy);
                if (length) {
                    dx /= length;
                    dy /= length;
                }
                delta = currentFrame - lastFrame;
                lastFrame = currentFrame;
                // move
                // delta is the elapsed time in seconds
                // SPEED is the speed in units per second (UPS)
                var x = dx * delta * enemySpeed;
                var y = dy * delta * enemySpeed;
                return {x,y};
            }

            	             
        </script>
    </body>
</html>
